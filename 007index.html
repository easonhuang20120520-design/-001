<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>FPS迷宮遊戲（LvX-Y完整版）</title>
<style>
  body { margin: 0; overflow: hidden; background: #333; }
  canvas { display: block; cursor: none; }
</style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>
<script>
const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 遊戲狀態
let running = true;
let dragging = false;

// 玩家設定
let player={x:1.5, y:1.5, dir:0, fov:Math.PI/3};
const moveSpeed=0.05;

// 關卡與地形
let level = 1;
let stage = 1;
const maxLevel = 5;
const stagesPerLevel = 3;
let terrainChangeCount = 0; // Lv3~Lv5地形改變次數

// 初始迷宮
let mapRows = 15;
let mapCols = 15;
let map = [];

// 牆貼圖（可選）
const wallTexture=new Image();
wallTexture.src='https://i.imgur.com/3r1m0gk.png';

// 隨機生成迷宮（DFS，可增加複雜度）
function generateMaze(rows, cols){
  let maze = Array.from({length:rows},()=>Array(cols).fill(1));
  function carve(x,y){
    const dirs=[[0,1],[1,0],[0,-1],[-1,0]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx=x+dx*2, ny=y+dy*2;
      if(nx>0 && nx<cols && ny>0 && ny<rows && maze[ny][nx]===1){
        maze[ny-dy][nx-dx]=0; maze[ny][nx]=0;
        carve(nx,ny);
      }
    }
  }
  maze[1][1]=0;
  carve(1,1);

  // 增加複雜度：隨機在空地增加牆壁小障礙
  const extraWalls = Math.floor((rows*cols)*0.05*terrainChangeCount); 
  for(let i=0;i<extraWalls;i++){
    const x = Math.floor(Math.random()*(cols-2))+1;
    const y = Math.floor(Math.random()*(rows-2))+1;
    if(maze[y][x]===0) maze[y][x]=1;
  }

  maze[rows-2][cols-2]=2; // 出口
  return maze;
}

// 根據難度生成迷宮（包含地形複雜度）
function newMaze(){
  let extraSize = terrainChangeCount; // Lv3~Lv5每次改變+1格
  mapRows = 15 + level*2 + extraSize;
  mapCols = 15 + level*2 + extraSize;
  map = generateMaze(mapRows,mapCols);
  player.x = 1.5;
  player.y = 1.5;
  player.dir = 0;
}

// 牆壁顏色
function getWallColor(level, shade){
  switch(level){
    case 1: return `rgba(${shade*200},${shade*200},${shade*200},1)`; // 灰色
    case 2: return `rgba(${shade*150},${shade*200},${shade*255},1)`; // 淺藍
    case 3: return `rgba(${shade*255},${shade*255},0,1)`; // 黃色
    case 4: return `rgba(${shade*200},0,${shade*255},1)`; // 紫色
    case 5: return `rgba(${shade*255},0,0,1)`; // 紅色
    default: return `rgba(${shade*200},${shade*200},${shade*200},1)`;
  }
}

// FPS渲染
function renderFP(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#555'; ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle='#888'; ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);

  for(let x=0;x<canvas.width;x++){
    const rayAngle=(player.dir-player.fov/2)+(x/canvas.width)*player.fov;
    let distanceToWall=0, hitWall=false, hitExit=false;
    const eyeX=Math.sin(rayAngle), eyeY=Math.cos(rayAngle);

    while(!hitWall && distanceToWall<20){
      distanceToWall+=0.05;
      const testX=Math.floor(player.x+eyeX*distanceToWall);
      const testY=Math.floor(player.y+eyeY*distanceToWall);
      if(testX<0||testX>=mapCols||testY<0||testY>=mapRows){
        hitWall=true; distanceToWall=20;
      } else {
        if(map[testY][testX]===1) hitWall=true;
        if(map[testY][testX]===2) hitExit=true;
      }
    }

    const ceiling=(canvas.height/2)-canvas.height/distanceToWall;
    const floor=canvas.height-ceiling;
    const shade=1-Math.min(distanceToWall/10,1);

    if(hitWall){
      if(wallTexture.complete){
        ctx.drawImage(wallTexture,0,0,wallTexture.width,wallTexture.height,
                      x,ceiling,1,floor-ceiling);
      } else {
        ctx.fillStyle = getWallColor(level, shade);
        ctx.fillRect(x,ceiling,1,floor-ceiling);
      }
    }

    if(hitExit){
      ctx.fillStyle='rgba(0,255,0,0.5)';
      ctx.fillRect(x,ceiling,1,floor-ceiling);
    }
  }

  // Lv3~Lv4 顯示2D迷你地圖
  if(level===3 || level===4){
    renderMiniMap();
  }
}

// 2D迷你地圖
function renderMiniMap(){
  const mapSize=200;
  const cellSize=mapSize/mapRows;
  const offsetX=20, offsetY=20;
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillRect(offsetX-2,offsetY-2,mapSize+4,mapSize+4);

  for(let y=0;y<mapRows;y++){
    for(let x=0;x<mapCols;x++){
      if(map[y][x]===1) ctx.fillStyle='grey';
      else if(map[y][x]===2) ctx.fillStyle='green';
      else ctx.fillStyle='white';
      ctx.fillRect(offsetX+x*cellSize,offsetY+y*cellSize,cellSize,cellSize);
    }
  }

  ctx.fillStyle='red';
  ctx.beginPath();
  ctx.arc(offsetX+player.x*cellSize,offsetY+player.y*cellSize,cellSize/3,0,Math.PI*2);
  ctx.fill();

  ctx.strokeStyle='red';
  ctx.beginPath();
  ctx.moveTo(offsetX+player.x*cellSize,offsetY+player.y*cellSize);
  ctx.lineTo(offsetX+(player.x+Math.sin(player.dir))*cellSize,offsetY+(player.y+Math.cos(player.dir))*cellSize);
  ctx.stroke();
}

// 準心
function drawCrosshair(){
  const size=10;
  const cx=canvas.width/2;
  const cy=canvas.height/2;
  ctx.strokeStyle='red';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(cx,cy-size); ctx.lineTo(cx,cy+size); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx-size,cy); ctx.lineTo(cx+size,cy); ctx.stroke();
}

// 鍵盤控制
const keys={};
window.addEventListener('keydown',e=>{
  keys[e.key]=true;
  if(e.key==="Escape"){
    running=false;
    document.exitPointerLock();
    alert("遊戲已退出！");
  }
});
window.addEventListener('keyup',e=>keys[e.key]=false);

// 點擊畫布啟動 Pointer Lock
canvas.addEventListener('click',()=>{ canvas.requestPointerLock(); });

// Pointer Lock 事件
document.addEventListener('pointerlockchange',()=>{ dragging = (document.pointerLockElement === canvas); });

// 滑鼠旋轉
canvas.addEventListener('mousemove',(e)=>{
    if(dragging) player.dir += e.movementX*0.002;
});

// 玩家移動與過關
function update(){
  let nx=player.x, ny=player.y;
  if(keys['w']||keys['ArrowUp']) { nx+=Math.sin(player.dir)*moveSpeed; ny+=Math.cos(player.dir)*moveSpeed; }
  if(keys['s']||keys['ArrowDown']) { nx-=Math.sin(player.dir)*moveSpeed; ny-=Math.cos(player.dir)*moveSpeed; }
  if(map[Math.floor(ny)][Math.floor(nx)]!==1){ player.x=nx; player.y=ny; }

  if(map[Math.floor(player.y)][Math.floor(player.x)]===2){
    stage++;
    let terrainChanged = false;

    if(stage > stagesPerLevel){
      stage=1;
      level++;
      terrainChangeCount = 0;
      if(level>maxLevel){
        alert("恭喜過關，遊戲已結束！");
        running=false;
        document.exitPointerLock();
        return;
      } else {
        alert(`升級到 Lv${level}-1`);
      }
    } else {
      alert(`進入關卡 Lv${level}-${stage}`);
    }

    // Lv3~Lv5地形改變提示
    if(level>=3 && level<=5){
      terrainChangeCount++;
      terrainChanged = true;
      alert(`Lv${level} 地形改變 ${terrainChangeCount} 次！`);
    }

    newMaze();
  }
}

// 遊戲迴圈
function gameLoop(){
  if(!running) return;
  update();
  renderFP();
  drawCrosshair();
  requestAnimationFrame(gameLoop);
}

// 初始化
newMaze();
alert(`進入關卡 Lv${level}-${stage}`);
gameLoop();
</script>
</body>
</html>
